using System;
using System.Collections;
using System.Collections.Generic;
using Unity;
using UnityEngine;
using UnityEngine.UI;

public class ShowText : MonoBehaviour {
    GameObject obj; //Объектная переменная для обращения к выпадающему меню
    GameObject text; //Объектная переменная для обращения к текстовому полю
    GameObject Target; //Объектная переменная для обращения к ImageTarget
    static int n = 20; //Размерность массивов(кол-во вариантов)
    string[] Task = new string[n]; //Массив строк для текстов для вариантов
    GameObject[] scene = new GameObject[n]; //Массив объектов для обращения к группам сцен(вариантам)
    int curent = -1; //Целая переменная для хранения старого варианта
    int newCurent; //целая перменная для хранения текущего варианта
    Vector3 TargerPos; //Векторная переменная, состоящая из 3 дробнах переменных, для хранения текущего положения ImageTarget относительно камеры
    Vector3[] ScenePos = new Vector3[n]; //Массив векторных переменных, состоящих из 3 дробных переменных, для хранения начальной позиции сцен(вариантов) относительно камеры

    // Start is called before the first frame update
    void Start () {
        //Заполнение массива текстов для вариантов
        Task[0] = "Вариант 1\nСоздать в окне трехмерную сцену, состоящую из чайника и икосаэдра вращающихся вокруг полупрозрачного цилиндра.";
        Task[1] = "Вариант 2\nСоздать в окне трехмерную сцену, состоящую из октаэдра и конуса, вращающихся вокруг полупрозрачного тора.";
        Task[2] = "Вариант 3\nСоздать в окне трехмерную сцену, состоящую из сферы и цилиндра вращающихся вокруг полупрозрачного тетраэдра.";
        Task[3] = "Вариант 4\nСоздать в окне трехмерную сцену, состоящую из тора и конуса вращающихся вокруг полупрозрачного икосаэдра.";
        Task[4] = "Вариант 5\nСоздать в окне трехмерную сцену, состоящую из тора, находящегося внутри полупрозрачного икосаэдра. Описанный тор вращается вокруг цилиндра.";
        Task[5] = "Вариант 6\nСоздать в окне трехмерную сцену, состоящую из сферы вписанной в полупрозрачный октаэдр.Сфера и октаэдр вращаются вокруг чайника.";
        Task[6] = "Вариант 7\nСоздать в окне трехмерную сцену, состоящую из полупрозрачного тора и каркасного конуса, вращающихся вокруг цилиндра.";
        Task[7] = "Вариант 8\nСоздать в окне трехмерную сцену, состоящую из каркасного икосаэдра и тора вращающихся вокруг полупрозрачного цилиндра.";
        Task[8] = "Вариант 9\nСоздать в окне трехмерную сцену, состоящую из чайника и додекаэдра вращающихся вокруг полупрозрачного цилиндра.";
        Task[9] = "Вариант 10\nСоздать в окне трехмерную сцену, состоящую из куба и каркасного конуса вращающихся вокруг полупрозрачной сферы.";
        Task[10] = "Вариант 11\nСоздать в окне трехмерную сцену, состоящую проволочного куба и полупрозрачного тора вращающихся относительно закрашенной сферы.";
        Task[11] = "Вариант 12\nСоздать в окне трехмерную сцену, состоящую из цилиндра и тора вращающихся вокруг полупрозрачного икосаэдра.";
        Task[12] = "Вариант 13\nСоздать в окне трехмерную сцену, состоящую из тора вписанного в полупрозрачный октаэдр.Тор и октаэдр вращаются вокруг цилиндра.";
        Task[13] = "Вариант 14\nСоздать в окне трехмерную сцену, состоящую из двух икосаэдров вращающихся вокруг полупрозрачного конуса.";
        Task[14] = "Вариант 15\nСоздать в окне трехмерную сцену, состоящую из икосаэдра и полупрозрачного конуса вращающихся вокруг чайника.";
        Task[15] = "Вариант 16\nСоздать в окне трехмерную сцену, состоящую из додекаэдра и каркасного конуса вращающихся вокруг полупрозрачной сферы.";
        Task[16] = "Вариант 17\nСоздать в окне трехмерную сцену, состоящую из тора вписанного в полупрозрачный додекаэдр.Тор и додекаэдр вращаются вокруг цилиндра.";
        Task[17] = "Вариант 18\nСоздать в окне трехмерную сцену, состоящую из проволочного икосаэдра и полупрозрачного додекаэдра, вращающихся вокруг цилиндра.";
        Task[18] = "Вариант 19\nСоздать в окне трехмерную сцену, состоящую из тетраэдра и полупрозрачного тора, вращающихся вокруг цилиндра.";
        Task[19] = "Вариант 20\nСоздать в окне трехмерную сцену, состоящую из додекаэдра и конуса, вращающихся вокруг полупрозрачного тора.";

        Target = GameObject.Find ("ImageTarget"); //Нахождение ImageTarget в сцене Unity по названию
        TargerPos = Target.transform.position; //Вычисление позиции ImageTarget
        string pattern = "Scene"; //Создание статического шаблона строки
        string patternInUse = ""; //Создания шаблона, которое будет меняться
        //Цикл для нахождения сцен(вариантов) и деактивации их внутри сцены Unity
        for (int i = 0; i < n; i++) {
            patternInUse = String.Concat (pattern, (i + 1).ToString ()); //Изменение шаблона для использования путём конкатинации строк статического шаблона и,переведённого в строку, итератора
            scene[i] = GameObject.Find (patternInUse); //Нахождение сцены(варианта) в сцене Unity по названию
            scene[i].gameObject.SetActive (!scene[i].activeSelf); //Деактивация сцены(варианта) в сцене Unity

            ScenePos[i] = scene[i].transform.position; //Сохранение координат сцены(варианта)
            patternInUse = ""; //Обнуление шаблона для использования
        }
    }

    // Update is called once per frame
    void Update () {

    }

    //Обработчик для взаимодейтвия с выпадающем меню
    public void ValueChanged () {

        obj = GameObject.Find ("DropdownUI"); //Нахождение выпадающего меню по названию
        text = GameObject.Find ("TextUI"); //Нахождение текстового поля в сцене Unity по названию
        SetCurent (obj.GetComponent<Dropdown> ().value); //Вызов функции для обработки текущей позиции
    }

    //Функция для смены позиции и состояния сцен(вариантов)
    void ChangeVisibility (int NewCurent, int OldCurent) {
        //Обработчик, который выполняет действия, в зависимости от того, какой флаг на вход пришёл в фунцию
        switch (OldCurent) {
            //Стандартный алгоритм
            default : scene[NewCurent].gameObject.SetActive (!scene[NewCurent].activeSelf);
            scene[NewCurent].transform.position = Target.transform.position;
            scene[OldCurent].gameObject.SetActive (!scene[OldCurent].activeSelf);
            scene[OldCurent].transform.position = ScenePos[OldCurent];
            break;
            //Алгоритм, который выполняется, когда пользователь впервые выбирает пункт меню, отличный от начального
            case -1:
                scene[NewCurent].gameObject.GetComponent<Renderer> ().enabled = false; //Отключение рендера для ключевой фигуры сцены(варианта)
                scene[NewCurent].gameObject.SetActive (!scene[NewCurent].activeSelf);
                scene[NewCurent].transform.position = Target.transform.position;
                break;
                //Алгоритм, который выполняется, когда пользователь выбирает переход на начальную позицию
            case -2:
                    scene[NewCurent].gameObject.SetActive (!scene[NewCurent].activeSelf);
                scene[NewCurent].transform.position = ScenePos[NewCurent];
                curent = -1; //Возврат в начальное состояние
                break;
        }

    }

    //Функция для обработки текущей позиции
    void SetCurent (int value) {
        //Если НЕ 0, то выбран один из вариантов, значит работаем по стандартному алгоритму
        if (value != 0) {
            scene[value - 1].gameObject.GetComponent<Renderer> ().enabled = false; //Отключение рендера для ключевой фигуры сцены(варианта)
            newCurent = value - 1; //Присваиваем новой позиции значение (Выбранный вариант - 1); Такой приём для облегчения взаимодействия с массивами
            ChangeVisibility (newCurent, curent); //Вызов функции, которая меняет положение и состояние сцен(вариантов)
            curent = newCurent; //Сохранение новой позиции меню
            text.GetComponent<TMPro.TextMeshProUGUI> ().text = Task[newCurent]; //Вывод соответсвующего теста в текстовое поле
        }
        //Если 0, то выбрано начальное положение, значит работаем по специальному алгоритму
        else {
            newCurent = curent; //Сохранение старой позиции в новой
            curent = -2; //Изменение переменной для старой позиции на значение для активации одно из специальных алгоритмов
            ChangeVisibility (newCurent, curent); //Вызов функции, которая меняет положение и состояние сцен(вариантов), со специальным флагом
            text.GetComponent<TMPro.TextMeshProUGUI> ().text = ""; //Обнуление текстового поля
        }
    }
}